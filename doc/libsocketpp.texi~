
\input texinfo
@settitle A Guide to Libsocketpp 0.1
@setfilename libsocketpp
@c %**end of header

@include version.texi

@copying
This manual is for libsocketpp, @value{VERSION}

Copyright @copyright{} 2017 Charlie Sale

@quotation
Permission is granted to GNU
@end quotation
@end copying

@titlepage
@title A Guide to Libsocketpp
@subtitle A tutorial to C++ streambased sockets
@author Charlie Sale

@c Start copyright page
@page
@vskip 0pt plus 1filll
@insertcopying

Published by GNU Manual

@end titlepage

@c Start short toc

@ifnottex
@node Top
@top A Guide to Libsocketpp

The C++ library libsocketpp is a combination of the C socket system
and the C++ standard I/O system. It includes classes for basic use
and extention.
@end ifnottex

@contents

@end contents

@setchapternewpage on

@c DOC START

@c Overview of project
@node Overview, Acquiring
@chapter Overview
Welcome to libsocketpp, the C++ library for networking sockets. If you don't know
already, a socket is a connection between two networking hubs like computers and
modems. Before now, the standard socket system for C++ was the C socket system. Although
excellent for C, the C socket system was designed for use in the C programming language,
not C++. One of the key differences between C++ and C is that C++ is object oriented, which
means that it uses classes and objects. One of the objectives of libsocketpp was to
integrate the C socket system into an object oriented system built for C++.

Another objective of libsocketpp is to integrate the C socket system into the C++
standard I/O system. The standard C++ I/O system is built around buffer and stream classes.
A buffer is a container of data to be moved over a stream, and a stream is a connection
between two points that sends and recieves data between the two points. The stream writes
data into and reads data from a buffer. Libsocketpp works on this system because the socket
sends and recieves data across the internet and stores the data into the buffer.

@node Acquiring, A Basic Tutorial, Overview
@chapter Acquiring
@menu
* Downloading:: Where to download libsocketpp
* Installing:: How to install libsocketpp
@end menu

@node Downloading
@section Downloading libsocketpp
1libsocketpp can be installed from two places: ftp.gnu.org and github.com.

To download from ftp.gnu.org, do the following:
@enumerate
@item
TODO

@end enumerate

To download from github via git, clone the url
@email{https://github.com/softwaresale/github.com}.


@node Installing
@section Installing libsocketpp

Libsocketpp uses the standard build process used by GNU. It goes
as follows:

@enumerate
@item
Enter directory that you downloaded socketpp into

@item
Configure: @code{$ ./configure --prefix=@samp{your-prefix}}

@item
Compile: @code{$ make}

@item
Optional check: @

@item
Install: @code{# make install}

@end enumerate


@node The Basics, An Indepth Tutorial, Acquiring
@chapter A Basic Tutorial

Now that you have libsocketpp installed and configured, let's cover the basics on usage.

@menu
* TCP:: Using TCP sockets
* FTP:: Using FTP with libsocketpp
@end menu

@node TCP
@subsection TCP

The primary socket set used in libsocketpp is the TCP socket.
If you don't know already, TCP sockets are streambased, which
means it fits perfectly into this streambased library. The
TCP socket process goes as such:

SERVER:
@enumerate
@item
A socket descriptor is created

@item
The socket descriptor is bound to a port

@item
The socket descriptor then calls a blocking
process to listen for incoming socket connections.

@item
Once a connection is found, a socket descriptor
representing the accepted client is then returned
for use.

@item
With that socket descriptor, a stream is set up
between the server and now connected. Now, data
can be sent to and from each connected member
via blocking read and write calls.

@item
Eventually, either the server or client will
disconnect, terminating the stream.

@end enumerate

CLIENT:
@enumerate
@item
A socket descriptor is created

@item
The socket descriptor then connectes
to the host and port on which a server is bound.

@item
Once the client is connected, it can now send
and recieve data with the server via the same
blocking calls implemented by the server.

@item
Eventually, the socket will terminate it's connection
with the server, and the stream is closed.

@end enumerate

The classes in libsocketpp work the same way as this. Here is an example of a client
program.

@example
#include <socketpp/tcp/socket.h>
#include <iostream>

using namespace std;
using namespace tcp;

int main(int argc, char** argv)
@{
  Socket sock("192.168.1.1", 8888);
  sock.connects();

  sock << "Hello World" << endl;

  sock.closes();

  return 0;
@}

@end example

Here is a breakdown of what each line does:
@enumerate

@item
@example
#include <iostream>
#include <socketpp/tcp/socket.h>
@end example

The first include statement includes the @code{tcp::Socket} class for use in the
program. The second includes I/O header files for C++.

@item
@example
using namespace std;
using namespace tcp;
@end example

These lines declare the usage of namespaces in our program. All of the TCP socket
classes are found in the namespace @code{tcp}. While neither of these lines are
necessary, they allow you to write @code{Socket sock} instead of @code{tcp::Socket sock}
every time you want to declare a Socket class

@item
@example
int main(int argc, char** argv) @{
@end example
This line is the main entry point to your C function.

@item
@example
        Socket sock("192.168.1.1", 8888);
        sock.connects();
@end example
The first one declares a @code{Socket} object called @code{sock}. The constructor
parameters are the connection values. The string being the host to connect to and
the integer being the port on which you are going to connect. The next line,
@code{sock.connects()} connects your socket object to the server with the supplied
data. The @code{connects} method can also be used to set connection data in the same
way as done in the constructor.

@item
@example
        sock << "Hello World" << endl;
@end example

This line writes the string @code{"Hello World"} to the server that it connected to.
This is done in the same manor as you would do when printing text to @code{stdout}
via cout, meaning you use the formatted output operator, @code{<<}, to write text.
Take special note of the @code{endl} at the end of the statement.
@strong{An @code{endl} is required to send any data using the formatted output operator.}
I will explain why later.

@item
@example
        sock.closes();
        return 0;
@end example

The line @code{sock.closes();} terminates the connection between the socket and server,
and the line @code{return 0;} is the standard successful return value from main.

@end enumerate


@node FTP
@subsection FTP

@c using FTP 

@node An Indepth Tutorial, Extending, The Basics
@chapter An Indepth Tutorial


@node Extending
@chapter Extending

@c end of doc
@node Index
@unnumbered Index

@printindex cp

@bye
