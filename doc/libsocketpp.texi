
\input texinfo
@settitle A Guide to Libsocketpp 0.1
@setfilename libsocketpp.info
@c %**end of header

@include version.texi

@copying
This manual is for libsocketpp, @value{VERSION}

Copyright @copyright{} 2017 Charlie Sale

@end copying

@titlepage
@title Libsocketpp
@subtitle A tutorial to C++ streambased sockets and accompanying tools
@author Charlie Sale

@c Start copyright page
@page
@vskip 0pt plus 1filll
@insertcopying

Published by GNU Manual

@end titlepage

@c Start short toc

@ifnottex
@node Top
@top A Guide to Libsocketpp

The C++ Library @code{libsocketpp} contains multiple top level and base classes
built on top of the C++ standard I/O system. This allows the user of the
library to use sockets like they would use cout or cin.

The program @code{sockp} is a shell interface for the socketpp library.
The purpose of this program is to allow socket functionality in the terminal,
where it might be useful.

The scriping language @code{socki} is an interpreter for a scriping language that
allows shell socket functionality, but in a script instead of direct user input.

@end ifnottex

@contents

@setchapternewpage on

@c DOC START

@node Overview, Tutorial
@chapter Overview

Welcome to Libsocketpp, the C++ socket library based on the standard C++ I/O system. Because it
is built on top of the standard C++ I/O system, sockets behave the same way as an @code{istream}
or @code{ostream} would work. Lets go over what that means exactly.

By saying that libsocketpp is built on top of the C++ standard I/O system, I mean that it inherits
standard classes included in the standard C++ library that are built for I/O functionality. Classes
like @code{cout} and @code{cin} are built on the same systems. The specific classes that libsocketpp
are built on are @code{streambuf}, which is a typedef of @code{basic_streambuf}, and
@code{iostream}, which is a typedef of @code{basic_iostream}. Let's cover what these classes do,
and then how they relate to libsocketpp.

Let's start with the class @code{iostream}. This class is whats known as a stream. A stream is a
device that formats and transports data over a connection. This means that it physically reads
and writes data between two places. The class @code{iostream} both reads and writes data via
methods inherited from @code{istream} and @code{ostream}. As said earlier, a stream only moves
data, which means that we are missing a part of the system: the buffer.

A buffer, embodied in the class @code{streambuf}, is the location in memory in which data is stored
to retrieved for sending and recieving. When a stream writes data, it retrieves data from the the
buffer and outputs it to the destination. Conversly, when a stream reads data, it places retrieved
data into the buffer. Once this read data is placed in the buffer, said data can be returned to the
user.

In order for a stream to use a buffer, a buffer is usually passed into it's constructor. In
libsocketpp, both the buffer and stream are combined into one class for easy usage.

A question that you might have is ``How does this I/O system relate to sockets?`` Well, the
type of socket primarily used in this library is a Transmission Control Protocol (TCP) socket.
A TCP socket is itself a stream. This means that data is transfered over a connection through
blocking read and write commands. Because TCP is a stream, it fits perfectly into the C++ I/O
system.

@c TODO talk about what can and can't do

@node Tutorial, Extending, Overview
@chapter Tutorial

Let's now talk about how to use this library.

@menu
* Acquring and Installing: Getting. How to get and install this package
* Compiling:: How to compile programs with this library
* Including:: Which files to include in your program
* Handling Errors: Errors. About errors in libsocketpp
* Constructors, Connecting, and Binding: Ctors. How to create useable objects and connect them
* Accepting Connections: Accepting. How to acccept connection from a server and user them
* Sending and Recieving Data: Sendrecv. How to properly send and recieve data across sockets
* Setting Options: Opts. How to set socket options.
* Closing Connections: Closing. How to close a connection
* License:: License for this document
@end menu

@node Getting
@section Acquring and Installing

@menu
* Acquring::
* Installing::
@end menu

@node Acquring
@subsection Acquiring

@c TODO fix this

@c end Acquiring

@node Installing, Compiling, Acquring
@subsection Installing

Because this package follows standard GNU build proceedures, install with the following steps:
@enumerate
@item
<<<<<<< HEAD
@code{$ cd @option{libsocketpp-dir}}
=======
@code{$ cd @file{libsocketpp-dir}}
>>>>>>> 9d7cb02dd0f2e546f141ebfeb3187f3fcf620833

@item
@code{$ ./configure --prefix=@option{install-prefix}}

@item
@code{$ make}

@item
@code{# make install}

@end enumerate

@c end Installing

@c end Getting

@node Compiling, Including, Installing
@section Compiling

This library installs both a static and dynamic library. If you want to keep dependencies down or want
to have a very portable program/library, copy the static library
(@file{@option{prefix}/lib/libsocketpp.a}) into your project directory and compile it it by doing

@code{$ g++ file.cc libsocketpp.a -o executable}.

If you want to compile with the dynamic library, then compile with the flag @code{-lsocketpp}. This
is assuming that your prefix is part of the standard library serach path of ld.

@c end Compiling

@node Including, Errors, Compiling
@section Including

All libsocketpp headers are found in the directory @file{socketpp/} in your prefix include directory.
From there, classes are broken down by specific function or protocol. Both the @code{Socket} and
@code{Server} classes are found int the @file{tcp/} directory. Note that these subdirectories
correspond with the classes namespace. This means the @code{Socket} is part of the namespace
@code{tcp}.

For example:
@example
#include <socketpp/tcp/socket.h>
#include <socketpp/tcp/server.h>

/* The rest of your project here */

@end example

@c end Including

@node Errors, Ctors, Including
@section Handling Errors
Errors in socketpp are fairly low level. Most functions return an integer value for testing if they
do not already return some sort of other data type. Generally, a function will return a negative
value (i.e -1). On success, most functions return @code{0} on success, so to test, you can write:

@example
int ret = socket_function();
if (ret != 0)@{
   // handle error  
@}
@end example

For more specific error handling, all standard C socket @code{errno} values are still set. There
are no new @code{errno} values set by this library: they just recycle what would already be set
by the standard system. Look at the errno documentation at the website
@indicateurl{http://www.virtsync.com/c-error-codes-include-errno}. This contains the number and
a brief description about each errno error value.

The constructors for @code{tcp::Socket} and @code{tcp::Server} both throw the @code{ctor_exe_t}
exception when calling their constructors. The constructor does not inherently throw the exception,
but if an error in encountered, it will abort and dump the core. Because of this, it is reconmended
that all constructor calls are acompnaied with a try/catch block.

@c end Errors

@node Ctors, Accepting, Errors
@section Constructors, Connecting, and Binding

Now, let's get into the actual classes and methods of libsocketpp.

@c end Ctors

@node Accepting, Sendrecv, Ctors
@section Accepting Connections

@c end Accepting

@node Sendrecv, Opts, Accepting
@section Sending and Recieving Data

@c end Sendrecv

@node Opts, Closing, Sendrecv
@section Setting Options

@c end Opts

@node Closing, Extending, Opts
@section Closing Connections

@c end Closing

@c end Tutorial

@node Extending, License, Tutorial
@chapter Extending

@c end Extending

@node License, Index, Extending
@chapter License
@include fdl.texi

@c end of doc
@node Index
@unnumbered Index

@printindex cp

@bye
